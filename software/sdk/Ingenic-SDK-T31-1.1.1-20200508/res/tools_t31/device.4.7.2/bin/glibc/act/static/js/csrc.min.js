(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];

var stringify = JSON.stringify;

module.exports = function (fn) {
    var keys = [];
    var wkey;
    var cacheKeys = Object.keys(cache);
    
    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        if (cache[key].exports === fn) {
            wkey = key;
            break;
        }
    }
    
    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            Function(['require','module','exports'], '(' + fn + ')(self)'),
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
    
    var scache = {}; scache[wkey] = wkey;
    sources[skey] = [
        Function(['require'],'require(' + stringify(wkey) + ')(self)'),
        scache
    ];
    
    var src = '(' + bundleFn + ')({'
        + Object.keys(sources).map(function (key) {
            return stringify(key) + ':['
                + sources[key][0]
                + ',' + stringify(sources[key][1]) + ']'
            ;
        }).join(',')
        + '},{},[' + stringify(skey) + '])'
    ;
    
    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
    
    return new Worker(URL.createObjectURL(
        new Blob([src], { type: 'text/javascript' })
    ));
};

},{}],2:[function(require,module,exports){

/**
 * fixme
 * this is workaround for <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1016720">1016720</a>
 */
(function () {
    var templates = document.querySelectorAll('template');
    if (templates.length === 0) {
        return;
    }
    var pass = true;
    for (var i = 0; i < templates.length; i++) {
        if (templates[i].childNodes.length !== 0) {
            pass = false;
            break;
        }
    }
    if (pass) { // polyfill un-needed
        return;
    }
    for (var j = 0; j < templates.length; j++) {
        var children = templates[j].childNodes;
        for (var c = 0; c < children.length; c++) {
            templates[j].content.appendChild(children[c].cloneNode(true));
        }
        while (templates[j].hasChildNodes()) {
            templates[j].removeChild(templates[j].childNodes[0]);
        }
    }
})();


},{}],3:[function(require,module,exports){

if (!String.prototype.includes) {
    String.prototype.includes = function() {'use strict';
        return String.prototype.indexOf.apply(this, arguments) !== -1;
    };
}

if (!String.prototype.padLeft) {
    String.prototype.padLeft = function() {'use strict';
        var matrix = arguments[0];
        if (typeof matrix === 'string') {
            if (this === null || this === undefined) {
                return matrix;
            }
            var ln = matrix.length;
            return (matrix + this).slice(-ln);
        } else {
            return this;
        }
    };
}

if (!String.prototype.padRight) {
    String.prototype.padRight = function() {'use strict';
        var matrix = arguments[0];
        if (typeof matrix === 'string') {
            if (this === null || this === undefined) {
                return matrix;
            }
            var ln = matrix.length;
            return (this + matrix).substring(0,ln);
        } else {
            return this;
        }
    };
}

if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (searchString, position) {
        var subjectString = this.toString();
        var p = position;
        if (position === undefined || position > subjectString.length) {
            p = subjectString.length;
        }
        p -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, p);
        return lastIndex !== -1 && lastIndex === p;
    };
}

},{}],4:[function(require,module,exports){
var $ = require('../utils/helper');

var pruuid = 1;
var filesBlobs = {};
var filesURLs = [];

function __clean_up() {
    $('.messages').innerHTML = '';
    pruuid = 1;
    filesBlobs = {};
    filesURLs.forEach(URL.revokeObjectURL);
    filesURLs = [];
    Array.prototype.slice.call($.$('.button')).forEach(function (button) { button.classList.add('disabled'); });
}

/**
 * @param {String} type
 * @param {String} fname
 * @param {String} id
 * @param {Function} getBlob
 * @param {String} [name]
 * @return {Promise}
 * @private
 */
function __get_link (type, fname, id, getBlob, name) {
    return Promise.resolve(getBlob())
    .then(function (blob) {
        var ref = type + '-' + id;
        var a = document.createElement('a');
        a.id = ref;
        a.download = name || fname + '.' + type.toLowerCase();
        a.textContent = name || type.toUpperCase();
        filesBlobs[ref] = blob;
        var url = URL.createObjectURL(blob);
        filesURLs.push(url);
        a.href = url;
        return Promise.resolve(a);
    });
}

/**
 * @param {String} fname
 * @param {Number} id
 * @param {String} [text]
 * @private
 */
function __get_message_entry(fname, id, text) {
    var template = $('#template').content;
    template.querySelector('.fname').innerHTML = fname;
    if (id) {
        template.querySelector('.clickable').setAttribute('ref', id);
    }
    var clone = template.cloneNode(true);
    var display = clone.querySelector('.display');
    if (text) {
        display.innerHTML = text;
        display.classList.add('error');
    } else {
        display.querySelector('.progress').setAttribute('ref', id);
    }
    return clone;
}

/**
 * @param {String} fname
 * @return {Number}
 * @private
 */
function __next_id (fname) {
    var id = pruuid++;
    $('.messages').appendChild(__get_message_entry(fname, id));
    return id;
}

function __unknown_format (fname) {
    return function () {
        $('.messages').appendChild(__get_message_entry(fname, null, 'unsupported format'));
    };
}

module.exports = {
    cleanUp: __clean_up,
    nextId: __next_id,
    getMessageEntry: __get_message_entry,
    getLink: __get_link,
    unknownFormat: __unknown_format,
    getBlobs: function() { return filesBlobs; }
};

},{"../utils/helper":6}],5:[function(require,module,exports){
require('../fixme');
require('../polyfill');

var $ = require('../utils/helper');

var workify = require('webworkify');
var jsn = require('../workers/jsn');

var any = require('./cany');

function convertJSON (fname) {
    return function (event) {
        var id = any.nextId(fname);
        var progress = $('.progress[ref="' + id + '"]');
        var worker = workify(jsn);
        worker.onmessage = function (event) {
            var result = event.data;
            if (result.done) {
                progress.value = 100;
                any.getLink('c', fname, id.toString(), function () {
                    return new Blob([result['cpp']], {type: 'text/x-c'});
                }, fname.replace(/\.[^.]*$/, '.c'))
                .then(function (a) {
                    $('.clickable[ref="' + id + '"]').appendChild(a);
                }).catch(function (error) {
                    console.log(error);
                });
            } else {
                progress.value = result.progress;
            }
        };
        worker.onerror = function (error) {
            var parent = progress.parentNode;
            parent.innerHTML = error.message;
            parent.classList.add('error');
        };
        worker.postMessage([event.target.result, id, fname]);
    };
}

function loaded () {
    $('#file-select').addEventListener('change', function (event) {
        any.cleanUp();
        var files = event.target.files || event.dataTransfer.files;
        for (var i = 0; i < files.length; i++) {
            var f = files[i];
            var reader = new FileReader();
            reader.onload = (function (f) {
                var fname = f.name.toLowerCase();
                if (fname.endsWith('.json')) {
                    return convertJSON(f.name);
                } else {
                    return any.unknownFormat(f.name);
                }

            })(f);
            reader.readAsText(f);
        }
    }, false);
}

if (document.readyState === 'complete' || document.readyState === 'interactive') {
    loaded(); // for Firefox
} else {
    document.addEventListener('DOMContentLoaded', loaded); // for Chrome
}

},{"../fixme":2,"../polyfill":3,"../utils/helper":6,"../workers/jsn":7,"./cany":4,"webworkify":1}],6:[function(require,module,exports){
module.exports = document.querySelector.bind(document);
module.exports.$ = document.querySelectorAll.bind(document);

},{}],7:[function(require,module,exports){

var getLicenseMessage = function () {
    var year = new Date().getFullYear();
    return '' +
    '/**\n' +
    ' *  This confidential and proprietary software/information may be used only\n' +
    ' *        as authorized by a licensing agreement from Apical Limited\n' +
    ' *\n' +
    ' *                   (C) COPYRIGHT ' + year + ' Apical Limited\n' +
    ' *                          ALL RIGHTS RESERVED\n' +
    ' *\n' +
    ' *       The entire notice above must be reproduced on all authorized\n' +
    ' *        copies and copies may only be made to the extent permitted\n' +
    ' *              by a licensing agreement from Apical Limited.\n' +
    ' *\n' +
    ' */ \n';
};

var getTypeByWidth = function (width) {
    switch (width) {
        case 1: return 'uint8_t';
        case 2: return 'uint16_t';
        case 4: return 'uint32_t';
        default: throw new Error('Bad width of integer variable');
    }
};

var convertLUT = function (lut) {
    var name  = '_' + lut['name'].toLowerCase(); // add an underscore because of a possible conflict with calibration defines
    var rows  = parseInt(lut['rows']);
    var cols  = parseInt(lut['cols']);
    var width = parseInt(lut['width']);
    var value = lut['value'];
    var comment = '';
    if (lut.hasOwnProperty('__comment')) {
        comment = lut['__comment'];
    }
    var cline;
    var cArray;
    if (rows == 1) { // 1D array
        cArray = JSON.stringify(value).replace( /\[/g, '{').replace( /]/g, '}');
    } else { // 2D array
        var idx = 0;
        cArray = ' {';
        for (var r = 0; r < rows; r++) {
            cline = '\n  { ';
            for (var c = 0; c < cols; c++) {
                cline += (value[idx] + ', ');
                idx += 1;
            }
            cline = cline.replace(/, $/, ' },');
            cArray += cline;
        }
        cArray = cArray.replace(/,$/,'\n}');
    }
    var source = '\n\n' +
    '// ' + comment + '\n' +
    'static ' + getTypeByWidth(width) + ' ' + name + '';
    if (rows == 1) { // 1D array
        source += '[ ]\n'
    } else {  // 2D array
        source += '[ ][' + cols + ']\n';
    }
    source += (' = ' + cArray + ';');
    return source;
};

var includeHeaders = function () {
    var source = '#include "apical_calibrations_id.h"\n';
    source +=    '\n';
    return source;
};

/**
 * @param {Worker} self
 */
module.exports = function (self) {
    self.onmessage = function(event) {
        var json  = JSON.parse(event.data[0]);
        var id    = event.data[1];
        var fname = event.data[2];

        var target = json.target;
        var luts = json['luts'];

        var cpp = getLicenseMessage();

        cpp += '\n';
        cpp += includeHeaders();
        cpp += '// created from ' + fname + ' on ' + new Date().toISOString() + ' UTC';

        for (var l = 0, len = luts.length; l < len; l++) {
            cpp += convertLUT(luts[l]);
            self.postMessage({id: id, progress: 40 * l / len});
        }

        var lut, name, rows, cols, width, value;
        cpp += '\n';
        for (var h = 0; h < len; h++) {
            lut = luts[h];
            name  = lut['name'].toLowerCase();
            rows  = parseInt(lut['rows']);
            cols  = parseInt(lut['cols']);
            width = parseInt(lut['width']);
            value = lut['value'];
            if (rows == 1) { // 1D array
                cpp += '\nstatic LookupTable ' + name + ' = {' + ' .ptr = _' + name + ', .rows = ' + rows + ', .cols = sizeof(_' + name + ') / sizeof(_' + name + '[0])' + ', .width = sizeof(_' + name + '[0] ) };';
            } else { // 2D array
                cpp += '\nstatic LookupTable ' + name + ' = {' + ' .ptr = _' + name + ', .cols = ' + cols + ', .rows = sizeof(_' + name + ') / sizeof(_' + name + '[0])' + ', .width = sizeof(_' + name + '[0][0] ) };';
            }
            self.postMessage({id: id, progress: 40 + 30 * l / len});
        }
        cpp += '\n\n';
        cpp += 'uint32_t get_' + target.toLowerCase() + '_calibrations( ApicalCalibrations * c ) {\n';
        cpp += '    uint32_t result = 0;\n';
        cpp += '    if (c != 0) {\n';
        for (var k = 0; k < len; k++) {
            lut = luts[k];
            name  = lut['name'].toLowerCase();
            cpp += '        c->calibrations[_' + name.toUpperCase() + '] = &' + name + ';\n';
            self.postMessage({id: id, progress: 70 + 30 * l / len});
        }
        cpp += '    } else {\n';
        cpp += '        result = -1;\n';
        cpp += '    }\n';
        cpp += '    return result;\n';
        cpp += '}\n';

        self.postMessage({id: id, done: true, file: fname, cpp: cpp});
    }
};

},{}]},{},[5]);
